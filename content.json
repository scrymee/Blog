{"posts":[{"title":"Excelのブック単位ですべてのシートをまとめて拡大・縮小する","text":"シートをまとめて選択して更新 シートをまとめて選択して更新# Shift+シート名をクリックによって、拡大・縮小したいシートを選ぶ。 右下の拡大・縮小バーを選択して変更する 一気にすべてが拡大される","link":"/2022/08/29/20220829Excel/"},{"title":"SVNTortoiseで特定のリビジョンの差分を取り込む","text":"特定のRevisionの差分を取得する 余談：ローカルで変更した差分を、取り消したい 特定のRevisionの差分を取得する# 指定したファイルのログを「show log」をクリックする 比較したい２つのRevisionをCtrlを推しながら２箇所を選択する 例えば下記のようにあり、Rev105からRev106とRev108の共通のコミットメッセージを取り込みたいのであれば、Rev105とRev108を比較すると、106と108で追記された差分を読み取ることができる。 123Rev 108. Imdex改修Rev 106. Index改修Rev 105. 管理画面改修 余談：ローカルで変更した差分を、取り消したい# 特定のファイルを選択して「show log」を選ぶ。 Revertを選ぶ Revertによってもとに戻すファイルが表示されるので、OKを押す Revert処理が始まり終わったら処理が終了する","link":"/2022/08/29/20220829Excel2/"},{"title":"phpで&amp;&amp;と||を用いたワンライナー条件説の挙動","text":"&amp;&amp;と||を真偽値の判定意外に条件説を使用できるっぽい 結論 動作確認 余談 &amp;&amp;と||を真偽値の判定意外に条件説を使用できるっぽい#下記に準じたコードを見かけた 12$hasData = true;$hasData &amp;&amp; $this-&gt;log('データを持っています'); 論理演算子は、if文の中で使用するイメージが合ったためわからなかったが、こういう記述があるようだ。感覚的にわからなかったので試してみた 結論#これは&amp;&amp;以前がtrueであれば後続の処理を実行し、falseであれば実行しないという記載らしい・ 要するに 12345$hasData &amp;&amp; $this-&gt;logMsg();if ($hasData) { $this-&gt;logMsg();} と同義らしい。年のために動作確認をする 動作確認#適当な真偽値を返却する無名関数を作成し、それを用いてテストする 12345678910111213141516function test(){ $true = function () { return true; } $false = function () { return false; } $echo = function () { echo 'echo関数が実行されました' }} これを使って書きを実行すると下記のような挙動になった 12345678$true &amp;&amp; $echo// =&gt; echo関数が実行されました$false &amp;&amp; $echo// =&gt; 何も出力されない$true || $echo// =&gt; 何も出力されない$false || $echo// =&gt; echo関数が実行されました まあ論理的に考えるとには&amp;&amp;のときのはじめの条件節がfalseだと後半が実行する必要がないため、trueのときのみ進行し、||のときは前半がtrueであれば後半は実行する必要がなくfalseのときは後半を実行する必要があるので、動作としては納得。 ただ、感覚的になじまないから基本的には使わないほうが良さそうな気もするなあ。。。。 余談#同僚と三項演算子の話をしたときに、「知らなかったからそうやって書いたことない」と聞いた。知らないことは別に良いのだけど、三項演算子の話とこの条件節のワンライナーは意味合いとして同じなのかなと思う。知っている人にとっては当たり前だから、手癖で書いてしまうけど、そうでない場合は未知のコードのように見えてしまう。かといって、三項演算子を使わない理由もないんだよなあ。と思うし、どのへんで折り合いをつけるか判断できない。これと三項演算子の違いはなんだろうか。自身が知っているか知らないかに集約されてしまうのだろうか？","link":"/2022/08/31/20220831php/"},{"title":"シェルスクリプトでの$1や$2などはデリミタによって認識される","text":"shellの引数はデリミタによって取得される xargsにn1オプションを付けた場合 改行を含むファイルに対しての特殊文字について 半角スペースや改行はデフォルトのデリミタとして指定されている awkを用いた特殊パラメータについて shellの引数はデリミタによって取得される#test.shとしてこういうのをつくる 12345678910#!/bin/shecho '$1の結果'echo $1echo &quot;--------&quot;echo '$2の結果'echo $2echo &quot;--------&quot; ちなみにechoの次の文字をダブルクオーテーションにすると$1や$2などの変数が展開されてしまうため、文字として出力したい場合はシングルクォーテーションを使う 1234567echo 'りんご みかん' | xargs sh test.sh$1の結果りんご--------$2の結果みかん-------- xargsにn1オプションを付けた場合#12345678910111213echo 'りんご みかん' | xargs -n1 sh test.sh$1の結果りんご--------$2の結果--------$1の結果みかん--------$2の結果-------- $2が取得できない（引数を1つずつ渡すため） シェルスクリプト内で用いられる$1や$2はsh test.shの引数なので納得できるでは改行のケースはどうだろうか 改行を含むファイルに対しての特殊文字について#test.txtとして、こういうものをつくる半角スペースと改行があるもの 123りんご みかんバナナ また、test.shに第三引数を取得するような処理を追加する 12345678910111213#!/bin/shecho '$1の結果'echo $1echo &quot;--------&quot;echo '$2の結果'echo $2echo &quot;--------&quot;echo '$3の結果'echo $3echo &quot;--------&quot; 実行 12345678910cat test.txt | xargs sh test.sh $1の結果りんご--------$2の結果みかん--------$3の結果バナナ-------- 改行も引数として利用された！！ そのため引数を2ずつと明示的に宣言してあげると2個ずつになる 1234567891011121314151617181920cat test.txt | xargs -n2 sh test.sh $1の結果りんご--------$2の結果みかん--------$3の結果--------$1の結果バナナ--------$2の結果--------$3の結果-------- つまり、引数として認識されるのは改行も半角スペースも同じなのだ 半角スペースや改行はデフォルトのデリミタとして指定されている# bashの場合「スペース」「タブ」「改行」（$’ \\t\\n’）といった値が初期設定されていて、これらが文字の区切りとして認識されています。 【シェルスクリプト】IFSで区切り文字（デリミタ）を変更する方法 | server-memo.net awkを用いた特殊パラメータについて#test.txtを再度使用する 123りんご みかんバナナ test.txtをawkで実行してみる 余談だがawkの中身をダブルクオーテーションにしたらすべてが出力された。理由は謎だがシングルクォーテーションを使おう 123456789101112131415# 1つ目の引数を取得するcat test.txt | awk '{print $1}'りんごバナナ# 2つ目の引数を取得する=&gt; 行単位で実行cat test.txt | awk '{print $2}'みかん#空文字# 3つ目の引数を取得する=&gt; 行単位で実行cat test.txt | awk '{print $3}'#空文字#空文字 awkで使われる特殊引数は、改行と半角スペースは明確に区別されているようだ おそらく、標準入力として受け取るか、引数として受け取るかの違いだろうな。cat test.txt | xargs sh test.sh の例だと引数として受け取っているので、これはxargsによって引数設定を行うことで、半角スペースとか改行の区別がなくなったのだろう またechoを用いた場合も次のようになる 123456789101112'りんご みかん' | awk '{print $1}'りんご'りんご みかん' | awk '{print $2}'みかんecho 'りんご みかん' | awk '{print $0}'りんご みかんecho 'りんご みかん' | awk '{print $3}'# 空文字 標準入力の場合は改行と半角スペースは区別されるようだ。同じ役割っぽいのに挙動が微妙に違うのは少し厄介だなあ","link":"/2022/09/04/20220904shel/"},{"title":"hexoをGithubにデプロイする","text":"Summary deploy用のライブラリインストール hexoをデプロイする準備 デプロイ 参考文献 Summary# Hexoをデプロイする \u001b deploy用のライブラリインストール#npm install hexo-deployer-git --save gitをhexoコマンドで使用するためのパッケージをインストールする hexoをデプロイする準備#hexoにはgithubにデプロイ用のコマンドがあるので、それを使うどのリポジトリにアップロードするかを設定する。 _config.ymlで&lt;更新＞の箇所を修正する 1234567891011# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://example.com # &lt;更新&gt;# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git # &lt;更新&gt; repo: https://github.com/{username}/{username}.github.io # &lt;更新&gt; branch: main # &lt;更新&gt; リポジトリのreposは、HTTPSで指定されているもの デプロイ#hexo deployで可能。hexo deploy -gとオプションを追記することで、静的ファイルの生成も同時に行う また上記ライブラリをインストールしていないと下記のようなエラーが出るので 1ERROR Deployer not found: git 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647NFO Validating configINFO Start processingINFO Files loaded in 49 msINFO 0 files generated in 20 msINFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in hexo/.deploy_git/.git/[main (root-commit) 93eef4a] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[main 906c1c0] Site updated: 2022-08-17 13:07:00 21 files changed, 6278 insertions(+) create mode 100644 2022/08/16/hello-world/index.html create mode 100644 2022/08/16/startHexo/index.html create mode 100644 2022/08/17/uploadHexo/index.html create mode 100644 archives/2022/08/index.html create mode 100644 archives/2022/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/fonts/fontawesome-webfont.woff2 create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/jquery.fancybox.min.css create mode 100644 fancybox/jquery.fancybox.min.js create mode 100644 index.html create mode 100644 js/jquery-3.4.1.min.js create mode 100644 js/script.js delete mode 100644 placeholder create mode 100644 tags/hexo/index.htmlEnumerating objects: 42, done.Counting objects: 100% (42/42), done.Delta compression using up to 8 threadsCompressing objects: 100% (31/31), done.Writing objects: 100% (42/42), 887.64 KiB | 15.04 MiB/s, done.Total 42 (delta 6), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (6/6), done.To https://github.com/hoge/fuga.github.io.git * [new branch] HEAD -&gt; mainBranch 'main' set up to track remote branch 'main' from 'https://github.com/scrymee/scrymee.github.io.git'.INFO Deploy done: git 完了する。githubのリポジトリにアクセスすると確認できる。 参考文献#Git Pages &amp; Hexoで手軽な無料Blogを作る - Qiita","link":"/2022/08/17/deployHexo/"},{"title":"個人的に好きなお酒","text":"最近、ジャンルフリーでお酒を楽しむ機会が増えてきた。 2021年に読んだプログラミング関連の本#桂月 CEL 24 純米大吟醸酒#桂月 CEL24 純米大吟醸 50® | 清酒 桂月 土佐酒造株式会社 おでんパーティを開催したときに、友人が買ってきた日本酒。 聞くと、「おでんに合うお酒を店員さんに尋ねたときに勧めてくれたもの」だとか。 たしかに、そのときに飲んだお酒の中で一番美味く衝撃を受けた。日本酒はそういうものなのかもしれないけれど、おでんを邪魔することもなく控えめながらもしっかりと甘さや旨味は出ているので、おでんの旨さをより際立たせてくれて、何度もおかわりしてしまったのは言うまでもない。 フルーティでスッキリとしており、日本酒が苦手な人でもするりと飲めそうな後味。 キンキンに冷やして飲むとうまかったので、そのときはワインよろしく氷水に浸けて飲んでいた。甘みが際立ち最高。 紀州梅酒 紅南高#梅酒 紅南高｜グランプリ受賞。紅色に染まった希少梅だけで造った梅酒 社会人になってボトルでお酒を買うようになったきっかけのお酒。 梅酒の味がガツンと効き香りも良い。非常に濃厚な味は居酒屋での梅酒とは違う味わいだった。単体でのパンチ力が強く、とにかくしっかりとした梅を感じたいときに飲みたい。 友人から振る舞ってもらって知ったのだけど、当時はビールばかり飲んでいた。 「梅酒は甘すぎて無理」などと避けていたのだけど、一口飲んで一目惚れ。その場でAmazonで注文をしてしまった。 黒ボトルも渋くて好み。 紀土#紀土 純米吟醸 しぼりたて 1.8L | 紀土・紀美野・純真無垢（平和酒造）和歌山県 | -酒やの鍵本 「ここの日本酒は安くてうまい」という友人から勧められた居酒屋で飲んだお酒。 これまで、居酒屋で飲む日本酒を好んで飲むことはなかった。後味の感覚がどうにも苦手で、度数が高く濃厚なので、すぐ飽きが来て酔っ払えない。今思うと恥ずかしい日本酒に対しての固定観念を覆してくれたお酒だった。 これは後味がスッキリしている上に、香りも良い。単体でも美味しいが、主張しすぎることもないので、魚介類との相性も良い。日本酒は大量に飲むものではなく食事と合わせて飲むものだというのを教えてくれた銘柄だった。 その後調べてみると、手頃な価格で手に入れられることもわかったので、個人的によく飲むことのある日本酒だ。 マリブ#マリブ MALIBU サントリー 最初飲んでびっくりした。お酒の種類をビール・梅酒・日本酒・焼酎・ウイスキー・カクテルくらいしか知らなかったので衝撃を受けた。非常に甘ったるいのに飲んでて飽きない、今までに飲んだことのないジャンルのお酒に驚いた。そしてコーラで割って飲んだら最高にうまい。それは知人と行ったバーで出してもらったのだが、普段同じお酒は頼まないのに、追加で2回も同じオーダーをしてしまった。 この衝撃を友人に伝えたら、「いや、マリブコーラって有名だよね？」と言われた。まじか〜〜。 曰く、「クラブやバーでは定番」とのこと。お酒っぽくない味なので、テンション上がればいくらでも飲めるなと思った。後日ドンキに行くと、めちゃめちゃ見かけた、納得。","link":"/2022/01/04/favorite-liquor/"},{"title":"やりたいことリスト","text":"ゴルフをする サーキューレータを買う 60kg台になる JSでゲームを作る 資格を3個取る Youtubeにキャンプ動画を上げる ゴルフをする#ゴルフスクールに通ってゴルフを打つ。コースを回れる・バッティングセンターみたく球を気持ちよく当てられるようになりたい サーキューレータを買う#=&gt; 買ったぞ！（2022/09/04）スノピのやつ。悩んだけど買ったら多幸感すごい！友達に相談してようやく踏ん切りがついた。「2週間悩んだんだったら買っていいと思う。」は金言 60kg台になる#69kgとかに戻す。大学時代の体重。筋肉もつけられるといいなあ JSでゲームを作る#マインスイーパーとかぷよぷよとかテトリスとか、そのあたりを何も見ずに作れるようになりたい 資格を3個取る#「XX持ってまーす」は経験を証明するものなので。学歴がそう。なぜか無意味という論調が多く勘違いしそうになるけど、実際どんな資格でも強いし、選ばれる一助になりうる。 Youtubeにキャンプ動画を上げる#とりあえず動画編集とかをやってみたいので。板倉さんのキャンプ動画を見て。","link":"/2022/08/31/20220831100list/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#ドメインなにかの領域にソフトウェアに適応する。領域がドメイン ドメインエキスパートに手助けしてもらって、役立つようなものを作るドメインエキスパートは、領域の専門家。 保守性を向上まさかりおじさん DDDの公演から、DDDの実践の場に適切だなあ ドメインが複雑なら ドメイン駆動設計を導入するために転職して最初の3ヶ月でやったこと[DDD] - little hands’ lab こういうテストでお手本を作るオニオンアーキテクチャなどでお手本などを実際に作る お手本は外部イメージもある ライブモデリングとコーディングで理解するDDD (DDD勉強会2021#1) - YouTube コンテキストマップを作って、コアドメインを見定める 問題領域：娯楽を楽しみたい 解決領域：サッカー動画配信サービスTVゲーム エンジニアの納得感を得なければならないなんのためにやっているのか？と混乱を招く。 今までの方法に固執してしまう 現場の課題とDDDによってどう解決するかを伝えるのが必要。DDDは機能性と変更用意性の向上 全部するのではなく、「負債が特にひどい箇所に絞って」 現場で役立つシステム設計の原則 SpatialChat（スペチャ）を仕様アイコンをドラッグして近くの人とおしゃべりできる 複数画面共有が可能 実際の設計から、スクラッチ（まっさらな状態から）設計実装するー＞そこで得た知見を共有する。o 規定集・マニュアルを用いて、それをMODELなどコードに落とし込んだ。 コードの重複が激減しているー＞UTがないとだめ Why の合意形成#悪い設計で失っているもの・良い設計で得られるの言語化、数値化 改修コストなのか、時間なのか Howの認識合わせ#一覧網羅ではなく、のうたんずけ WEhatの体験学習#イミュータブルドメインオブジェクトを実際に動かす 悪いサンプルを作るのは難しい 記憶から呼び戻して作る","link":"/1984/01/24/hello-world-copy/"},{"title":"Hexoのテーマ「Icarus」カスタマイズまとめ","text":"IcarusはHexoのThemeの一つである。 公式ドキュメント Icarus 作者のサイト 如何给 Icarus 增加夜间模式 - iMaeGoo’s Blog Icarusで記事のデザインを変更したい#「サムネイルの表示先を変更したい」「サムネイル未指定時にデフォルト画像を設定したい」「コメントや寄付ボタンなどの不要な機能を一旦削除したい」と思った。 そういうときには、themes/icarus/layout/common/article.jsxを修正する。(テーマのフォルダ名によっては、themes/に続くファイルパスがicarus/ではないかもしれない) 下記のように機能別でタグが書かれている。コメントアウトするなり、位置を変更したり条件節を追加して上げると良い。 12345678910{/* Thumbnail */}{ {has_thumbnail(page) ? &lt;div class=&quot;card-image&quot;&gt; {index ? &lt;a href={url_for(page.link || page.path)} class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;thumbnail&quot; src={get_thumbnail(page)} alt={page.title || get_thumbnail(page)} /&gt; &lt;/a&gt; : &lt;span class=&quot;image is-7by3&quot;&gt; &lt;img class=&quot;thumbnail&quot; src={get_thumbnail(page)} alt={page.title || get_thumbnail(page)} /&gt; &lt;/span&gt;}&lt;/div&gt; : null} } Icarusでサイドバーのウィジェットを変更したい#themes/icarus/_config.ymlにてウィジェット情報が記載されている。例えば、初期表示されている「Google FeedBurner」と「Google Adsense」のウィジェットを非表示にする場合は、コメントアウト（または削除）してあげるだけで良い 変更前#1234567891011121314151617181920212223# Tags widget configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: tags# Google FeedBurner email subscription widget configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: subscribe_email # Hint text under the email input description: # Feedburner ID feedburner_id: ''# Google AdSense unit configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: adsense # AdSense client ID client_id: '' # AdSense AD unit ID slot_id: '' 変更後#1234567891011121314151617181920212223# Tags widget configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: tags# # Google FeedBurner email subscription widget configurations# -# # Where should the widget be placed, left sidebar or right sidebar# position: left# type: subscribe_email# # Hint text under the email input# description: # # Feedburner ID# feedburner_id: ''# # Google AdSense unit configurations# -# # Where should the widget be placed, left sidebar or right sidebar# position: left# type: adsense# # AdSense client ID# client_id: ''# # AdSense AD unit ID# slot_id: '' カテゴリを階層化せずに使用したい#Hexoではカテゴリやタグの書き方は下記のようになる。 12345678title: Hexoのテーマ「Icarus」カスタマイズまとめdate: 2021/12/28 12:01:00categories: - プログラミングtags: - 環境構築 複数のカテゴリを指定すると階層化されてしまう プログラミング&gt;Hexoと階層化されてしまう。 1234567title: Hexoのテーマ「Icarus」カスタマイズまとめdate: 2021/12/28 12:01:00categories: - プログラミング - Hexotags: - 環境構築 対応策として、配列で記載する。これにより配列内に記載した組み合わせが階層化される。そのため別のリストで記載したカテゴリは階層化されない。 1234567title: Hexoのテーマ「Icarus」カスタマイズまとめdate: 2021/12/28 12:01:00categories: - [プログラミング] - [Hexo]tags: - 環境構築 おわりに#icarusはダークモード（night mode）を実装できる点と見た目のスマートさから導入した。見た目も良いね。","link":"/2021/12/28/icarus-update/"},{"title":"2021年に読んだプログラミング関連の本まとめ","text":"2021年に\bは、プログラミングの本を多く読んだ。エンジニアに良く推薦されている名著を中心に読んだことがあるので、知られている本が多いのだが、やはり長年人気がある本ということもあって大変勉強になった。勉強になったとはいえ、どうしても一読した限りでは理解しきれないものばかりだ。方法ではなく原理が多く、頭では理解できていても実践として活かすことができていない。特にエンジニアとして活動し始めた頃に読んだ本を今読み直すと、いくつもの発見がある。 2021年に読んだプログラミング関連の本#リーダブルコード#","link":"/2021/12/28/programming-books/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new &quot;My New Post&quot; More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2022/08/16/hello-world/"},{"title":"Hexoをローカル環境で構築する","text":"HexoはNode.jsの静的サイトジェネレーターツールの名称である。静的サイトのため、データベースなどは不要な点が特徴。加えて、Markdownで記事を作成するため、サービスに依存しない。作成した記事は、Serverを起動することで確認できるが、コマンドによってHTML形式で静的サイトに変換できる。 Hexoのインストール方法#Node.jsへHexoのインストール#Node.jsの実行環境は構築済みとする。DockerでNode.jsのイメージを使用した。 1npm install -g hexo Hexoの雛形作成#下記コマンドでひな形ファイルを作成できる。※APPはプロジェクトの名前 1hexo init APP その結果、下記のようなディレクトリ構成で作成される 12345678910├─ .github├─ node_modules├─ scaffolds├─ source| └─ post.md| ├─ themes| └─ landscape├─ _config.yml Localでの確認方法#下記コマンドで実行可能 1hexo server themesの変更#下記サイトからHexoのテーマを選択できる。Themes | Hexo こちらからgithubのページへアクセスできる。そこから該当テーマのディレクトリをダウンロードする。（Download ZIP または git clone XXX)ダウンロードしたファイルは、themesファイル内に配置する。（hexo initのときにはlandscapeディレクトリが配置されている） その後、_config.ymlにて記載されているthemeをthemesファイル内にあるテーマのディレクトリ名へと変更する テーマについて#Hexoのicarusは下記が作者のサイトになっている如何给 Icarus 增加夜间模式 - iMaeGoo’s Blog また、themesによっては別のライブラリをインストールする必要がある。たとえば、icarusを適用した場合下記のようなライブラリをインストールするコマンドを実行する。 これらのコマンドは、hexo server実行時のエラーで案内される。 1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.14.0 inferno@^7.3.3 inferno-create-element@^7.3.3 おわりに#icarusはダークモード（night mode）を実装できる点と見た目のスマートさから導入した。見た目も良いね。","link":"/2021/12/28/hexo-init/"},{"title":"Sedで前のデータを使いたいときの「¥1」後方参照の使い方","text":"¥1は後方参照と言われるもの 後方参照の確認 ディレクトリ置換 ¥1は後方参照と言われるもの#¥1を用いると前のデータをそのまま引用することができる。 つまりmvなどで一括リネームするときなどに活用できる そもそも、¥1の使い方を確認する。 まずこれを使う。 ここでのxargsは引数を1つにすることで縦に見やすくするために使っている。xargsはコマンドを入力しないとxargs echoと同じ意味になる 123echo 'apple banana' | xargs -n1applebanana 後方参照の確認#正規表現を用いて確認する 123echo 'apple banana' | xargs -n1 | sed -r 's/^(....)/¥1 ¥1 /g'appl appl ebana bana na つまり文頭4文字を置換する処理を書いた。置換したい箇所を括弧で囲むと、後で置換対象を¥1と参照できる またこれは2つ以上も用いることができるので覚えておこう。 123echo 'apple banana' | xargs -n1 | sed -r 's/^(..)(..)/¥1 -&gt; ¥2 /g'app -&gt; le ban -&gt; an a 完全に余談だが、確認のために下記のように書くと置換前のデータが全て出力されているように誤解した。これは置換対象と、それ以外がそのままくっつくことであたかも同じように見えることだ。 1234567echo 'apple banana' | xargs -n1 | sed -r 's/^(....)/¥1 ¥1/g' # 上との違いは末尾に半角スペースがないappl applebana bananaecho 'apple banana' | xargs -n1 | sed -r 's/^(..)/¥1/g' # 上との違いは末尾に半角スペースがないapplebanana つまり、これを用いたらファイル名の数字をディレクトリ階層へと変更する処理も可能だ ディレクトリ置換#本来echoでかいているところはlsなどで実行していると考えて欲しい 1echo '20201231test.txt' | sed -r 's|^(........)(.+)|¥1¥2 ¥1/¥2|g' | xargs -n2 mv これでよい。実行は下記のようになる 1mv 20201231test.txt 20201231/test.txt ただ、mvコマンドは、ディレクトリがない場合失敗するためディレクトリを作成する操作も必要にな","link":"/2022/09/05/howToUseSedInshell/"},{"title":"Javascriptで「特定の要素が出るまでtryする」のためにWhileを使う","text":"whileに怯えない Jsのwhileの使い方 whileに怯えない#JSに限らず、上記の場合はWhileを使用すると良い。なんとなく、whileは無限ループを引き起こしうると聞いたことがあり、感覚的にも理解できるのだが、場合によっては使われているケースもある。検索系だと、こんなケースもあった。 1234567891011121314while(true) { //ループ処理や加工などを繰り返した後に if($connect) { return $connect; } $retryCount++; if($item === null) { $this-&gt;getItem(); echo &quot;${$retryCount}回のリトライ&quot;; break; }} 必ずブレイクするような処理で抜けるように指定してあげると良いただ、本当にループの終了漏れがないか確認することは肝心だが、、、 要するに、while (true)といった一見すると危険そうに見える処理も実際に使用されているため、使い方に注意するのは当然ではあるが、そこまで怯えなくて良さそう Jsのwhileの使い方#たとえば、ランダム文字列を抽出するが、それが重複しないようにユニークな値とする場合 1234567let y, xdo { y = Math.tranc(Math.random() * 10); x = Math.tranc(Math.random() * 10);} while (!board[y][x])board[y][x] = true; 特定の座標にランダムにデータを入れる場合の処理。上記のコマンドは、whileの中がtrueになるまで続ける処理だ。 上記の場合は、do内は必ず1回は実行されるそして、!board[y][x]がtrueつまり、値が入っていない状態になるまで設定し続けるのだ。 ちなみに、while内の変数はdo外にでも指定しておかなればエラーになるので注意。 他にも下記のように書いてあげると、上とは逆になる。つまり、whileの中がfalseになるまで続けられる 12345678910getData = falsewhile (dataCount &lt; 5) { if(hasData) { dataCount++; }} **trueになるまで続ける場合は、do while falseになるまで続けるのは通常のwhile**なのを覚えておこうね","link":"/2022/09/05/howtouseWhileInJs/"},{"title":"セキュリティ情報の定番確認方法","text":"セキュリティ部署からのアナウンス 脆弱性番号とは？ 一般的な脆弱性の告知サイト IPA JVN Security Next セキュリティ部署からのアナウンス#先日セキュリティ部署からのアナウンスがあった。 下記のような内容だ。もちろんすぐに対応して報告した。 Chrome更新をお願いします Chromeの更新 / High / CVE-XXXXXX深刻度High0-day攻撃であるため攻撃事例が検出済み必要な行動Chromeをバージョン「XXXX」に更新しブラウザを再起動詳細XXXXXXX脆弱性番号CVE-2022-XXXX ところでこれらはどこから入手しているのだろう？気になる点を調べてみた 脆弱性番号とは？#脆弱性番号とは、CVEから始まる数字。非営利団体が運営している、個別製品中の脆弱性を対象として採番される識別子。 いままでは、脆弱性を告知するサービスが独自基準で交付していたが、A社とB社で告知されたアナウンスがそれぞれ同一の脆弱性告知かを判断できないケースが続いた。そのため識別子番号を設定しており、その深刻度からHighやMiddle、Lowなどが設定されている。 攻撃対象や機密性や可用性などどの性質に対しての影響が大きいかなども分類されている 一般的な脆弱性の告知サイト#IPA#一般的な脆弱性告知団体。サイトもある。 「Microsoft製品の脆弱性について（2022年5月）」など特定の製品についての情報も多い。 また後述するJVNに関する脆弱性もある程度網羅しているように見えるJVNとの確認の使い分けは実際に使用しているものが日本の製品かで分けても良いと思う。 日本製品の場合は下記のJVNを中心に、MicrosoftやAdobeなど世界的な製品であればIPAで良さそう。ただ、なんとなくだけどここで告知されるケースは限られている気がするので、メルマガなどに登録するか他のサービスと併用が良さそう。 上記のChromeの脆弱性については更新されていなかった。 どちらかというとセキュリティキャンプやIT人材の育成など、セキュリティ報告以外にも多くのことをしているイメージ。 JVN#CVEが全世界のセキュリティに関する脆弱性を包括しているのに対して、JVNは日本の脆弱性に対する情報を管理しているデータベースとなっている。IPAも運営に携わっている。 ここでIPAと共同運営しているJPCERTは脆弱性がIPAに報告された際にどのように対処するか製品の開発者に検証や対策を行うのをサポートする組織。 ざっとみたところ、JVNは基本的にはCVEの割り当ても行われている、、、と思われる。「富士電機製XXXXにおける」「オムロン製CX-XXXX」といった日本社のものが多いように見える。 Japan Vulnerability Notes Security Next#セキュリティ被害事例や脆弱性報告がある メールの誤送信や、USBメモリの紛失といった他のニュースサイトでは取り上げられない情報も網羅している。おすすめ","link":"/2022/09/05/security/"},{"title":"Promiseで対話的処理を実現する","text":"対話的処理を実現したい Promiseのresolveについて理解する 1. inputResolveにPromise内の引数であるresolveが登録される。 2. その後awaitなので後続の処理は実行されず、待機する 3. btn.onclickが実行されたときに1の関数を呼び出してあげる 4. 外部からのresolve()の実行によってawaitの戻り値がセットされ処理が進む まとめる 例えばこんな感じで実装 対話的処理を実現したい#下記のような処理で対話処理を実現しているケースが有った。 なにか入力してくださいの文言が出たあとに、 DOMで定義したbtn要素に準じたものをクリックしたら、 「Messageですね。OKです！」と出力される というフローだ。 基本的には、whileがtrue要素で無限ループされるのだが、async awaitによってawait要素で次の処理が停止される。await要素はresolveが返却されるまで待機される。そして「Message」がresolveに登録されることで、ようやく次の処理が進行される。そしてすぐに、ループ処理となり、「なにか入力してください」が再度出力される。 12345678910111213141516171819202122let inputResolve = null;window.onload = () =&gt; { btn.onclick = () =&gt; { inputResolve('Message'); } talk()}const talk = async() =&gt; { while (true) { console.log(`なにか入力してください`) const input = await new Promise( resolve =&gt; { inputResolve = resolve; }) console.log(`${input}} ですね。OKです！`) }} このあたりの動作がどうも納得できなかったので確認する Promiseのresolveについて理解する#処理の流れを細かく分類すると下記になる。 1. inputResolveにPromise内の引数であるresolveが登録される。#resolveはfunctionだと思ってもらって差し支えない。 そう考えるとinputResolve = resolveということは実質的に下記と同じ。 1234567let inputResolveinputResolve = () =&gt; { //処理} つまりこの関数を呼び出す場合は、inputResolve()で呼び出すことができるというわけ。 2. その後awaitなので後続の処理は実行されず、待機する#まあいうまでもなく。 3. btn.onclickが実行されたときに1の関数を呼び出してあげる#呼び出すことにより、Promise内でよく記載しているresolve()が実行されるのと同意義となる。もしinputResolveのカッコ内に文字列を入れた場合は、resolve('MESSAGE')などと同じだろう 12345const input = await new Promise (resolve =&gt; { resolve('MESSAGE')}) これを見ると、inputにはresolve内の文字であるMESSAGEが格納される。 そして、このresolve()はPromise内ではなく外部から実行しても成立するようだ 4. 外部からのresolve()の実行によってawaitの戻り値がセットされ処理が進む#あえて書くと下記のようだろう。ただ、resolveはnew Promiseに紐付いているようだ。内部に何かしら識別子でもあるのだろうか。 123456789resolve('MESSAGE') // 実際にはこのように書いてもPromise内のResolveを呼び出しているわけではないので動かないが、意味合いとしてはこういう感じで呼び出していると思ってもよいconst input = await new Promise (resolve =&gt; { resolve('MESSAGE') // これをPromise内部で行うのではなくグローバル変数を用いて外部で実行しても処理としては成立する}) そのため、Promise外でも使用できるようにグローバル変数を定義してresolveを登録する。 それを変数で関数化したものを使って別のタイミングで呼び出してあげることで、await後続がすすむというわけだ まとめる# new Promise内のresolve（関数）を変数に入れる その変数をグローバル化する 変数を任意のタイミングで呼び出すとawaitにしているnew Promiseが進行するo というわけだ 対話的処理で状態を管理し、ループにより同じだが文言が違うようなクイズ処理などで活躍しそうだ。#これを用いたらforなどの中でも一時的に処理を停止して、ユーザーからの入力を待つことができる。クイズ問題の配列をループさせ、随時問題と会話を行うこともできるだろう。 なかなか良いアイデアだよなあ。 まあNode.jsとか使えばもっと簡単なんだろうけど、この発想は大好き。 例えばこんな感じで実装#1234567891011121314151617181920let inputResolvewindow.onload = async () =&gt; { talk() console.log('loading...'); await new Promise(r =&gt; setTimeout(r, 2000)) inputResolve('やっほー')const talk = async() =&gt; { console.log('start'); const answer = await new Promise(resolve =&gt; { inputResolve= resolve }) console.log(answer) console.log('end'); console.log('');} こうなるはずだ 123456789101112131415startloading...// 2秒待つやっほーendstartloading...// 2秒待つやっほーend....","link":"/2022/09/09/Javascript/"},{"title":"jsでGameを作るときの座標関係を簡単に導入するロジック","text":"Summary Summary# jsでゲームを作るときの一般的な座標関係について 落ちゲーなどを作るときに座標が必要になるケースが有る。リバーシや将棋、囲碁・テトリス・ぷよぷよなど多くあるだろう。これは特定の位置の座標の状態に応じて表示内容を変化させることで実現している。そのため、ゲームを作る上で下記のような座標を作りたくなるケースが有る。 123456789const board = [ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] これは下記のようにすると作成できる 12345678910const height = 10;const width = 10;let board = [];for(let y = 0; y &lt; height; y++){ for(let x = 0; x &lt; width; x++){ board[y][x] = &quot;0&quot;; }} これによりjsで座標を指定することができるので、例えば次のようにオブジェクトをもたせても良い。 12345678910111213const height = 10;const width = 10;let board = [];for(let y = 0; y &lt; height; y++){ for(let x = 0; x &lt; width; x++){ board[y][x] = { text: '0', status: 'open' }; }} これにより将来的な処理で、オブジェクトのプロパティを参照できる。 123456789101112131415const height = 10;const width = 10;for(let y = 0; y &lt; height; y++){ for(let x = 0; x &lt; width; x++){ if(board[y][x].open) { //指定した座標がopen状態の時の処理 } else { //指定した座標がclose状態の時の処理 } }}","link":"/2022/08/17/20220817jsGame/"},{"title":"シェルスクリプトのxargs内で複数の変数を使用する","text":"Summary ユースケース 実行するシェル 解説 Summary# シェルでワンライナーで加工前の変数と加工後の変数を使用する方法\u001b shell -c 'XX'を用いる ユースケース#特定のファイルの出力ファイルをディレクトリ名から取得する 123$ ls -1apple-ringo.txtfish-sakana.txt 実行するシェル#1find ./app/tests/ -name *.txt | xargs -I@ sh -c &quot; VAR=`sed 's/-//g'`; phpunit @ --coverage-php reports/$VAR.php&quot; 解説#実行シェルのfindで、app/tests配下のファイルを全取得する 123$ find ./app/tests/ -name *.txtapp/tests/apple-ringoTest.phpapp/tests/fish-sakanaTest.php その後xargs -I@で取得した値を引数として渡すが、引数の１つを加工したい。 sedで置換した値をVARという変数に代入。（変数にコマンド結果を代入したい場合はバッククオートを使う) その後、セミコロンで次の処理を書く @内の変数とVARの変数がそれぞれ使用できるので記載する 1~3までの処理をsh -cで囲んであげる 最終的に下記のようなコマンド郡が実行される 12phpunit app/tests/apple-ringoTest.php --coverage-php reports/appleringoTest.phpphpunit app/tests/fish-sakanaTest.php --coverage-php reports/fishsakanaTest.php これでよし","link":"/2022/08/17/20220817shell/"},{"title":"hexoをdeployしたgithubのリポジトリからgithubPagesを確認する","text":"Summary Summary# すでにあるリポジトリをgithubPagesとして使用する リポジトリに移動する settingsを選択 Pagesのサイドバーを選択 urlが確認できるのでアクセス 反映には10分程度要することがあるため、すぐ確認ができるわけではないようだ。 GitHub Pages サイトを作成する - GitHub Docs","link":"/2022/08/17/20220817publishMaster/"},{"title":"非同期処理のPromiseとasyncとawaitの使い方","text":"画面描写を人間に違和感なく表現するAjax 非同期処理は実行順序を保証しない Promiseについて PromiseはResolverを返却することで終了を認識する Promiseオブジェクトにはthen関数がある async await asyncはPromiseオブジェクトを返却する関数となる 混乱しないようにまずはpromiseを使おう 画面描写を人間に違和感なく表現するAjax#業務中に「この取得処理は重いからajaxで非同期処理で実装しよう」というケースが有った。イメージとしては、ユーザーが登録している欲しい物リストを10件抽出し、TOPページに表示するという内容に近い。 要するに、TOPページの描写と並行して、非同期処理で負荷のかかるロジックを実現することで、負荷のかかる処理を終えることなくそれ以外の画面を描写しておくことでユーザビリティを上げようとした。 それ自体は、Ajaxを使えば問題なく実装できるのだけど、Ajaxとjsとの組み合わせは実行順序の観点から注意すべき点がある 非同期処理は実行順序を保証しない#非同期処理の概念を知っていると当然だが、非同期処理は実行順序が上から行うことを保証しない。 そしてjavascriptでありがちな、特定の要素をクリックすると何かしらの処理を行うようなクリックイベントの登録もこの影響を受ける つまり下記のようにAjaxの処理でHTMLを画面上に付与する場合、&lt;button id=&quot;btn&quot;&gt;がajaxで表示される前に、const btn = ...が実行されるため、btn変数の中はnullになってしまう。 1234displayBtnDOMForAjax(); // Ajaxの取得処理const btn = document.getElementById('btn'); なので、非同期処理が実行したあとに、処理を走らせたいというケースがある。 こういうときに使用できるのがasync awaitだったりする。 Promiseについて#非同期処理の実行順を制御するときは、基本的にはPromiseというオブジェクトを利用する。 非同期処理は実行順序を保証しないので、それをPromiseでラップするイメージでいいのかな。 余談だけど、「じゃあ非同期やめればいいじゃん」って思ったので改めて確認しておく。非同期をやめると指定の処理が終わるまで次の処理が実行されない。これではユーザビリティが下がる。そのため、非同期で実装したいが、一部を逐次的に実行したいというときにPromiseを使う。 PromiseはResolverを返却することで終了を認識する#Promiseを使って実装すると、Promiseオブジェクトが返却されるのでPromise内で実行された非同期処理の中での戻り値を設定しても取得できない。そのため、Promiseの中では、Resolverを宣言する。 これはfunctionでいうところのreturnのようなもので、new Promiseの中で記載しておくと、その戻り値はresolver(&quot;ここ&quot;)になる。 Promiseオブジェクトにはthen関数がある#Promiseオブジェクトには、then関数が定義されている。そのためPromise内のthen関数を用いて下記のようにかける 1234567new Promise((resolver) =&gt; { // 非同期処理 resolve($resultData)}). then(() =&gt; { // 非同期処理終了後にやりたいこと}) Promise.prototype.then() - JavaScript | MDN こうやって実行順序を保証する。 ただ、冗長だしネストが深いということで、asyncなどを用いる async await#上記の処理はasyncとawaitを使うと次のようにかける 1234567891011121314151617function getData(){ return new Promise( resolver =&gt; { //非同期処理 resolve('success') })}async function init(){ await getData() // getDataの非同期処理が終わりを待って実行}//init を実行するinit(); awaitを使うときはasync関数の中で使用しなければならない。できないのだが、仮に任意の場所で使用することができてしまうとすべての処理が逐次処理になってしまうだろう。上記の場合init()という関数を非同期処理で呼び出すので、init()以下の後続の処理も実行される。なのでawaitをしたいときはasyncで関数化してあげて、それも非同期処理としてあげないといけない。 実行順序を決めるための非同期処理をPromiseでラップし awaitで実行順を記載した処理をまとめて非同期処理の宣言であるasyncをつける それでasync関数は非同期で実行されるために、後続処理も結果を待たずに使用できる という感じだろう asyncはPromiseオブジェクトを返却する関数となる#new PromiseによってPromiseオブジェクトを返却するのだが、カッコが多くて視認性が悪い。そのためasyncを使えば new Promiseやresolveを見慣れた書き方に変えられる 123456789101112131415161718192021222324// function getData()// {// return new Promise( resolver =&gt; {// //非同期処理// resolve('success')// })// }// 上記はasyncを使うとここまで簡潔に書ける。これは全く同じ意味async function getData(){ return 'success' })}async function init(){ await getData() // getDataの非同期処理が終わりを待って実行}//init を実行するinit(); まあこのせいで、asyncとawaitの関係がごちゃごちゃになる。。。awaitを使う関数にasyncをつけるのか？でもawaitはasyncの中でしか使えんけどどういうこと？？とかそういう。。。 混乱しないようにまずはpromiseを使おう#結果だけ覚えてしまうと絶対にまた混乱してしまうのは目に見えている。なれるまでは、Promiseで書いて、その後リファクタリングでPromiseオブジェクトをasyncに書き換えて上げるほうがイメージ付きやすい気がするね。","link":"/2022/09/01/20220901javascript/"},{"title":"phpファイルの閉じ処理「?&gt;」は書かないようにしようね","text":"phpの閉じカッコについて 余談 参考文献 phpの閉じカッコについて#phpをファイル内に記載するときは、&lt;?php内に処理を記載する。こちらの末尾の?&gt;は基本的には不要だ。 12345&lt;?php// phpの本文?&gt; これで良い。 1234&lt;?php// phpの本文 なぜかというと、php処理を閉じてしまったあとに、２行以上の改行がある場合、文字列としてファイルが空白文字を出力してしまうケースが有るちなみに、１行の空白行であれば、phpがいい感じに処理してくれるようだが、2行以上あるとそれ移行は、アウトプットされてしまう。要するに、htmlタグなどを記載しているのと同じ状況になるというわけだ。 意図しないアウトプットが発生することにより、このようなエラーが発生するWarning: Cannot modify header information - headers already sent by XXX これは、アウトプット直後にheaderを更新するリクエストを贈ろうとした際に発生するので、空白行が存在していると、発生する こういう事情から、末尾の?&gt;はViewの役割を持つHTMLタグを記載する箇所以外では使わないほうが、自然であろう。 余談#更に付け加えると公式ドキュメントのheader関数にて記載がある header() 関数は、 通常の HTML タグまたは PHP からの出力にかかわらず、すべての実際の 出力の前にコールする必要があることです。頻出するエラーとして、include または require 関数、他のファイルをアクセスする関数に 空白または空行があり、header() の前に出力が 行われてしまうというものがあります PHP: header - Manual headerを書き換える処理は、&lt;?phpの上にも何も書いてはだめ。classの関数呼び出しの際は、上から処理を取得するってことではないのかな？挙動がわからないけど、閉じカッコは使わないほうが良さそう 1234567&lt;html&gt;&lt;?php/* これはエラーとなります。この上に出力があることに注目してください。 * それはheader()のコールより前であるということになります */header('Location: http://www.example.com/');exit;?&gt; 参考文献#PHP の headers already sent エラーはどう直したらいいですか？ - スタック・オーバーフロー","link":"/2022/08/19/20220819php/"},{"title":"Hexoのthemeにicarusを導入する","text":"icarusのダウンロード icarusのダウンロード#themeが公開されているgithubはこちら ppoffice/hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo. ここでzipファイルをダウンロードする。 また、npmを用いてインストールできるようだこれでpackage.jsonにicarus関連の情報が追記される 12npm install -S hexo-theme-icarus hexo-renderer-inferno zipファイルをダウンロードした場合は、zipファイルを解答し、themesに移動する。そのときのディレクトリ名はicarusなどに変更しておく。 その後、_config.ymlのthemeにて、上記で変更したディレクトリ名（icarus）に変更する。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus ちなみにこのときのthemeに入力するテーマ名をtypoしてしまいエラーとなってしまう。10分程度悩んでしまった。 また、hexo s後にERRORが出る場合があるので、これをインストールする。 1234567891011121314151617INFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===ERROR Package hexo-pagination's version (1.0.0) does not satisfy the required version (^2.0.0).ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save hexo-pagination@^2.0.0ERROR or:ERROR yarn add hexo-pagination@^2.0.0 上記に従い書きを実行する。その後hexo sを実行すると再度同様にあたらしいパッケージを追加でインストールするように案内されるため、それには従っていく 12npm install --save hexo-pagination@^2.0.0npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^1.2.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 これでOK！画面が崩れているケースもあるのでhexo sを再度実行する","link":"/2022/08/19/20220819hexo/"},{"title":"ダイエット周りの疑問点","text":"例えば1日で10kg痩せるだけのカロリーを消費するなら痩せる？ でも運動し続けて体調崩さなければ痩せられるのでは？ カロリー不足で脂肪が消費されるというけど、太っていてもお腹がへるのはなぜ？ お腹が空くとお腹が鳴るが？ 太っている方が脂肪を持ち上げている分、筋肉がほかよりありそうだが？ 増量期ってなによ。太ってから痩せるなら太ってるほうがお得？ ダイエットについての疑問が多かったのでざっと調べた。その内容をまとめる。真偽の程は不明。大前提として、「これが原因であれば、極端な話、XXXということも可能ではないか？ただそうなってないのはなにか理由があるのだろうな」の精神で調べている。なので正当かどうかはプロに任せるとして、腑に落ちるかどうかで調べた。 例えば1日で10kg痩せるだけのカロリーを消費するなら痩せる？#理論上は痩せられるのかな。1kg痩せるためには7200kcal消費が必要と言われているので、それを基準に考えると、フルマラソンを何回もしないと痩せないのでそもそも体調崩すので不可能では。 引用一週間に７ｋｇ痩せるのは簡単だとリンク先では言っています。一日に脂肪１ｋｇ減らす計算ですが脂肪１ｋｇあたり７２００Kcalとして一日に７２００Kcal減らす（食事制限含む）ことは簡単ですか？ - Quora 一日１キロの脂肪燃焼は常人には不可能です。理由はコレです：人間は一日で脂肪を代謝してエネルギーに変換する限界があります。脂肪は燃焼が遅く、エネルギーへの転換が遅く、一日にエネルギーに変わる量に制限があります。こちらの研究：A Limit on the Energy Transfer Rate From the Human Fat Store in Hypophagia まあ痩せる前に人体がぼろぼろになるというのはわかる。 でも運動し続けて体調崩さなければ痩せられるのでは？#体調不良は免疫力の低下によってウイルスや菌が活発になり発生するっぽい大量の一度にカロリーを消費すると、カロリーを生み出す行為が優先されて免疫力が低下するのかもなあという仮説。 人間はロボットではないので。。。 カロリー不足で脂肪が消費されるというけど、太っていてもお腹がへるのはなぜ？#空腹は、血糖値の増減により発生する。血糖値が相対的に低くなると空腹感を感じる。カロリーの消費有無にはあまり関連性がなさそう。 なので、血糖値の上昇によりインスリンが分泌され、その結果過度に血糖値がインスリンによって消費されることで、相対的に血糖値が減少し空腹を感じる。 その理論でいうと、血糖値をあげないようにしたら、空腹を感じない→食べ過ぎを減らせるのでは？ お腹が空くとお腹が鳴るが？#これは胃の収縮運動によって発生する。この収縮運動は消化の際はもちろん、空腹を感じているとき（血糖値が低いとき）に特に発生するため。空腹以外でもお腹は鳴る！止めるにはどうすればいい？ | belta piu ｜ ライスフォース「肌を育むスキンケアプログラム®」 太っている方が脂肪を持ち上げている分、筋肉がほかよりありそうだが？#足とかはそうかも？手は持ち上げているのではないので筋肉は関係なさそう 増量期ってなによ。太ってから痩せるなら太ってるほうがお得？#増量期 ≠ 太る 増量期は、筋肉と脂肪を両方つける期間。筋肉だけつけるのは難しい。（なぜなら筋肉と脂肪は概ね同じ内容の栄養素が必要であるため）。だから筋肉と脂肪を一気につけて、その後脂肪を落とすのが増量期の仕組み。減量期も筋肉だけ残して脂肪だけ落とすというのは難しい。カロリーをへらすと筋肉の維持に必要なカロリーも不足気味になるため、ただ、筋肉の低下を下げる方法はいくつもあるので、それを実践する。 だから、太っている人が痩せることで筋肉をつけられるわけではなく、太っている人がもともと持っている筋肉を減らさないように筋トレをしながらダイエットをするのだったりする。","link":"/2022/09/01/20220901diet/"},{"title":"shellのオプションのユースケース紹介","text":"シェルのオプションのユースケース紹介 デバッグ機能をつけたい shellで実行中にエラーが出たら処理を停止する 参考文献 シェルのオプションのユースケース紹介#シェルのオプションのユースケースを検討時点で紹介していく デバッグ機能をつけたい#シェルスクリプトで変数に値を渡してそのコマンドを実行する処理を書いた。その結果どのようなコマンドが実行されたかを確認したい -xオプションを使うと良い。 sh -x XXX.sh また、シェルファイルに書く場合は 1#!/bin/bash -x と書いても良いらしいし、特定のロジックのみ確認したい場合はset -xとset +xで囲むなぜかシバン内に書いても動作しなかったので、基本的にはsetを使う 1234#!/bin/bashset -xecho 'TEST'set +x shellで実行中にエラーが出たら処理を停止する#これはあえて付けるというより、なぜかシェルスクリプトが最後まで実行されないケースがあったときに調査するとこのオプションが付いていたからだったという経験に基づく -eオプションで、処理がエラーで返却された時点で後続の処理を実行させない sh -e XXX.sh ちなみに直前の終了ステータスは$?で確認できる 下記のようにhogeディレクトリに移動して、fugaファイルを作りたいスクリプトのときに、使うだろう。ちなみに僕の場合はphpunitの実行が途中で終わってしまうのが不明で困っていたら、シェルの実行にこのオプションが付与されたいたためだったという経験がある。 123456cd hogemkdir fuga もしeオプションを付与せずに実行した場合。hogeファイルが無いという処理は進むが、現在のディレクトリにfugaファイルを作成してしまう。つまり、./fugaが作成される。 ./hoge/fugaを作る場合は、きちんとeオプションをつける 参考文献#シェルスクリプトの罠を避ける三つの tips - Qiita","link":"/2022/08/19/20220819shell/"},{"title":"hexoの目次をプラグインを導入する","text":"Summary# プラグインのインストール _config.ymlにtoc情報を追記 目次を挿入したい箇所にtocを記載する \u001b プラグインのインストール#hexoで目次を出力するためのプラグインをインストールする npm install hexo-toc --save _config.ymlにtoc情報を追記#12345678toc: maxdepth: 6 class: toc slugify: transliteration anchor: position: after symbol: &quot;#&quot; style: header-anchor 目次を挿入したい箇所にtocを記載する#123&lt;! -- toc --&gt; これでよし。余談だが、tocはTable of contentsの頭文字を取得したもの。目次という意味。 僕は、scaffoldsディレクトリのpost.mdに事前に追記している。 12345678910111213---title: {{ title }}date: {{ date }}categories: - programmingtags: - ---&lt;!-- toc --&gt;&lt;!-- more --&gt; これでいい感じに見出しが挿入される","link":"/2022/08/18/20220818hexo/"},{"title":"phpunitを使うときのTips一覧","text":"phpunitを実行しやすくるために実装レベルで修正したいこと 別の関数を呼び出すときはclassプロパティに値を挿入する mockの使い方 phpunitを実行しやすくるために実装レベルで修正したいこと#Testの修正ではどうにもならないので実装レベルで直したいことについて 別の関数を呼び出すときはclassプロパティに値を挿入する#別のクラスの関数を呼び出すときに、下記のように関数内でインスタンスを宣言してから関数を呼び出すケースが有る。 123456789public function getUser(){ // ..中略 $userClass = new User(); $user = $userClass-&gt;find($id); // ..中略} これで動作上は問題ないのだが、テストの観点から見ると、この関数getUser()自体は別のクラスの関数を使用しているため依存度が高くなる。つまりテストを実行するときは、Userクラスのfind関数の動作まで保証して動作確認する必要がある。 もし、Userクラスのfind関数は別途テストケースを設けている場合は、テストが重複してしまう。さらに、上記の例だと簡単でよいが、条件説が複雑に絡み合っており、戻り値がすぐに判断できないようなケースがあるとすると、実装時は問題なくても将来的に保守する側やテストケースを新たに追加する場合困る。 下記コードの説明。 12345678910111213141516171819202122public function getUserPost($id, $name){ // ..中略 // ------------------- // ユーザーインスタンスを呼び出す // ------------------- $user = new User(); // ------------------------------ // ログインユーザーがItemを持っているときの関数での処理 // ※ログインユーザー情報をもとに、created・name・adress・nicknameの情報が // なければ例外を返却してしまい処理が進まないことが400行程度のコードを読み解くとわかる // (本来そのようなデータが存在しないため考慮していなかった) // そのためここを通過させるためにユーザーをログインさせた状態をテストコードに追記する必要がある。。。ただ、ここはhaveItemList()関数のテストで記載すれば良い話なので、ここであえてその条件を追記するのは手間。 // ------------------------------- if ($user-&gt;haveItemList()) { // 中略 } else { // ..中略 }} こういうケースではUserの情報に必要な情報を調査する必要がある。最終的にコメントアウトにあるように必要な情報がわかったが、それらはこの関数のテスト自体になんの影響もないため、実際のところは、haveItemListの戻り値がtrueかfalseを設定できればよいだけなのに、関係ない箇所の調査に時間を要した。またこの関数自体では必要のないログインユーザーの情報を設定する必要もあった。テストケースも重複して記載することになりスマートではない。 これらの問題は、次で説明するmockやstubを使用することで依存関係の分離を実現できるのだが、上記の悪例のコードではmockなどを使用できない。 そのためできる限り外部の関数を呼び出すときはプロパティに持たせる。これはphpunitの機能でprivateプロパティの値をoverwriteする機能があるため、これを用いることができるようになる。上記のままであると、上書きができない。 12345678910111213141516private $_user;public function __construct() { $this-&gt;_user = new User();}public function getUser(){ if ($user-&gt;haveItemList()) { // 中略 } else { // ..中略 }} この場合は、$_userのプロパティをmockやstubに置き換えてあげることで__constructなどを実行せずに、プロパティを指定できることから、haveItemListの依存関係から抜けられる mockの使い方# mockを作成する 実行回数、引数それぞれの期待値を入力する 外部関数のmockに組み込む これで、外部関数の依存関係をなくした上でmockを作成できる期待値ごとにテストを書いてあげると良い","link":"/2022/08/18/20220818phpunitTips/"},{"title":"ツールはいつ作るべきか","text":"ツールは何を基準に作るか問題 直近で2回は行うであろう単純or複雑な作業はツール化を試みる ツールは何を基準に作るか問題#「これあると便利だな」と思ってもツールを使うまでに至らないケースが有る。というかツールを作ろうと発想が生まれないケースも多々ある。逆に何を持って作るのだろうかと思った。 現在upload.shなどを作成し、 hexoの静的書き出し githubへのアップロード バックアップの保存 をまとめて行うようにしている。記事を書いたらこのシェルを実行するだけでもろもろよしなにやってくれるのだ。 これは非常に便利だ。ステップ数が多いケースはどうしても面倒になってしまうのでワンライナーで実行できるようにしたのはすごく良い。 とはいえ、これは思いつきで作ってうまく進んだ例で、再現できるかわからない。 再現できるようにしたい。 そう思ったきっかけが、同僚がSQL解析用のツールを作成していたことだ。 いままでは、なんとなく「DBのこのテーブルと。。。このテーブルがINNERJOINされているから、このテストをするためにはここを追記して。。。でもこの値がNULLだったらWHERE対象から外れるから。。。」と随時考えながらデータを整形して作成していた。 それらをGUIでこの正しいデータをINSERTする SQLを作成するためのツールを作ってくれた。フラグ管理などを裏で設定してくれるので、データに挿入したいテキストデータなどを少し入力するだけで任意のデータを作成できる。 これはあまりにも便利すぎる。 すべてのSQLを読み取りどんな値が必要かを抽出する時間は明らかに手間がかかる。 そして、数ヶ月もすると何が必要だったか忘れてしまう。時間を要してしまうのでもったいないなと。 それを簡単に出力できるのは願ったりかなったりだ。 こういうときにツールは便利なのだろう。GUIが面倒ならAPIでも良いだろう。とにかく単純作業や複雑な作業を繰り返している事に気づいたとときは、まず自動化できないかを考えてみると良さそうだ。 直近で2回は行うであろう単純or複雑な作業はツール化を試みる#実践だと、適切なデータの挿入や、複雑なSQLの読み取りのときにはツールが有用だ。 値が返却される最低限必要なものを出力できるようなツール（特に言うならユニークな値を一部書き換えられる内容だとよし）はその時時点では遠回りに見えるかもしれないが、それを2回以上繰り返す場合は概ねトータルで見ると良い結果になることが多い。 なので、調査を直近で2回行う場合はツールを作ってみても良いと思う","link":"/2022/09/12/whenCreateTool/"},{"title":"vscodeの拡張機能のPasteImageを導入する","text":"Summary Paste Image。とは Paste Imageのインストール PasteImageの設定 使用方法 参考文献 Summary# vscodeの拡張機能「Paste Image」を導入しよう 導入して使いやすいように、setting.jsonを編集しよう。 Paste Image。とは#VsCodeの拡張機能で、画像キャプチャしたデータをmdファイルに貼り付けられる機能markdownで貼り付けた際は、指定したディレクトリに画像ファイルを自動で保存してくれる。 Paste Imageのインストール#vscodeの拡張機能で下記をインストールする。 Paste Image - Visual Studio Marketplace\u001b PasteImageの設定#setting.jsonにPasteImageの設定を追記する。下記をそのままコピペするといい。これはmarkdownを貼り付けた際に、どういう形式で保存するかを記載している 1234567&quot;pasteImage.defaultName&quot;: &quot;Y-MM-DD-HH-mm-ss&quot;,&quot;pasteImage.insertPattern&quot;: &quot;![](${imageFilePath})&quot;,&quot;pasteImage.path&quot;: &quot;${projectRoot}/source/images/${currentFileNameWithoutExt}&quot;,&quot;pasteImage.basePath&quot;: &quot;${projectRoot}/source&quot;,&quot;pasteImage.forceUnixStyleSeparator&quot;: true,&quot;pasteImage.prefix&quot;: &quot;/&quot; ${projectRoot}は、VScodeで開いているワークスペースのディレクトリパスとなる。 使用方法#クリップボードにコピーした画像を、貼り付けてあげると良い。貼り付ける際は、shift + command + Pで表示されるコマンド欄に、paste imageと入力してそれを選択してあげると貼り付けられる。 このとき、このコマンドに対してショートカットキーを設定することもできるので設定するとよいだろう。 僕のPCはMacなので、shift + command + ctrl + 4でクリップボードにコピーしshift + command + ctrl + Vでクリップボードからmdにペーストできるようにしている 参考文献#Hexo によるブログ執筆環境の構築 | /etc/openjnyGitHub+VSCodeでのMarkdownドキュメンテーションのプロジェクトルールを考える","link":"/2022/08/18/20220818vscodePasteImage/"},{"title":"gitのリモートリポジトリのブランチ名を指定してPUSHする","text":"gitで現在のブランチをリモートリポジトリの指定ブランチにPUSHする ローカルと別のブランチ名のリモートブランチにPUSHするコマンドをいつ使うのか 実例 参考文献 gitで現在のブランチをリモートリポジトリの指定ブランチにPUSHする#下記のようにコロンで指定すると別名のブランチにPUSHすることができる 12// ローカルの developブランチを、origin 上の release ブランチに push するgit push origin develop:release 記載しない場合は、同名のブランチにPUSHする ちなみに最新の作業を指定プランチにPUSHしたい場合下記のようにもかける 1git push origin HEAD HEADは現在のブランチの先頭を指し、作業ブランチ名も取得される。個人的にはブランチを切り替えているのを忘れてPUSHするようなケースもありうるので、明確に書くほうが良いようには思えるが。。。 ローカルと別のブランチ名のリモートブランチにPUSHするコマンドをいつ使うのか#githubのリポジトリを作り、ローカルでmasterブランチを使って作業していた。定期的にバックアップを残したいが、そのたびに別のブランチを作成するのは手間だ。そういうときに下記のようにするとブランチでバックアップを残せる。 1git push origin master:2022backup-master 僕が実際に使ったケースとしては、hexoを使用しているときだ。masterブランチは、hexo dによって一部のファイルのみ保存されている状況だが、hexoで出力したアプリケーションファイルをすべてバックアップとして残しておきたかった。特にmdファイルはhexo dだと保存されないため、将来的な移植にも不便だ。 そこで、mdファイル保存用のリポジトリを作成しようと思ったが、管理に手間がかかる懸念があった。そこで同じリポジトリのsrcブランチで、hexoで使用している全ファイルのbackupを残すこととした。 ※ブランチを切り替えることで、ファイルが閲覧可能状態になるため下書きなどを使用しているのであれば、あまり推奨はしない。リポジトリを分けることをおすすめする。 実例#hexoのディレクトリをすべてPUSHした。 1234567891011# gitを作成git init# gitのリモートリポジトリとの接続git remote add origin [repository-name]# git addgit add .# git commitgit commit -m 'first commit'# git pushgit push -u origin main:src mainで作業しているが、srcブランチが作成されPUSHできた 参考文献#ブランチを指定して git push する方法 | WWWクリエイターズ","link":"/2022/08/18/20220818git/"},{"title":"キャッシュの役割に関しての知見","text":"キャッシュについての知見を得る動機 キャッシュは高速化だけでな負荷軽減の役割がある そもそもクエリキャッシュはMysql8で廃止される キャッシュをぶん回す キャッシュについての知見を得る動機#MYSQLのバージョンアップ時に、急激に負荷が高まるケースが有った。詳しく調査するとMySQL8にてクエリキャッシュが廃止されるため負荷が高まるため発生するということだった。 そもそもキャッシュの意義について明確に理解していなかったのだが、今回のケースで明確になったので一旦事例を整理しておく。 キャッシュは高速化だけでな負荷軽減の役割がある#もともとクエリキャッシュはMYSQLのSELECT文などの結果をMYSQL内にキャッシュとして保存しておくことで呼び出し時の負荷を軽減することを目的としていたようだ。 ただ、MYSQL8.0で廃止され、代わりにRedisなどの外部キャッシュを利用するように推奨されている。 実際クエリキャッシュがなくなることで、CPU負荷がかかり速度が明確に落ちたようだ。 いままでこういうのを意識するほどのケースに遭遇しなかったが、キャッシュには高速化の他に負荷軽減の役割があったようだ そもそもクエリキャッシュはMysql8で廃止される#まあなくなるので詳細は割愛 キャッシュをぶん回す#「SELECTでデータを抽出しているロジックすべてにキャッシュを入れようか」という案が検討される程度には規模が大きくなるにつれてキャッシュの意義は増していく。それくらい気持ち極端なマインドでいても良い気がする","link":"/2022/09/14/sql/"},{"title":"VSCode以外のエディタをサブエディタとして使う理由","text":"VSCodeをインストールしている場合他のエディタは不要と思っていた VSCodeでワークベンチの作成は時間を要する 目的別にエディタを用意 VSCodeをインストールしている場合他のエディタは不要と思っていた#VSCodeがあるのに他のエディタ（サクラエディタなど）を使用している理由がわからなかった。全部VSCodeでいいし、拡張機能もあるし、他のエディタを使用する理由がないよなあと。 なんとなくVSCode前に他のエディタを使っていて、それに慣れているからなんだろうなと思っていた ただ、ちょっとVSCodeでは不便に感じるケースがいくつか出くわした VSCodeでワークベンチの作成は時間を要する#簡単な修正（テキストだったりマークダウンだったり、設定ファイルだったり）はわざわざVSCodeの便利な要素を使う理由がない。そういった軽微な修正によって、VSCodeを起動する場合、起動までのラグがきになってしまう。 VSCodeは拡張機能だったりを読み込むので起動に時間がかかる。 これらのケースは、長時間同じエディタで作業する場合は有効だが、数秒程度の修正には不要だったりする。 特に僕の場合、リモートリポジトリのワークベンチを作成しているのでローカルのファイルを起動してもそこが同時に読み込まれてしまったりする そのため目的に応じたエディタの使い分けが必要に感じてきた 目的別にエディタを用意#正直、Vimでもいいのだけど、Vimのデフォルトは視認性が悪いのであまり好きではないいい感じに修正しても良いけれど、ファイルをダブルクリックしたときに起動するエディタを指定しておくほうが直感的だったりする。 なのでサクラエディタをインストールした。 ふむう。使い分けだなあ","link":"/2022/09/20/tool/"},{"title":"気になったら病院に行こうね","text":"気になったら病院に行こうねという話 病院は怖かった 高額？ 診察早すぎない？ どこいけばいい？ 余談：お薬手帳はお得なのでおすすめ 気になったら病院に行こうねという話#マスク荒れがひどくて1〜2年程度悩んでいた（厳密に言うと気にしていなかった）のだが、先日皮膚科に行って処方箋を出してもらった。 その結果、2週間程度で荒れが引き、1ヶ月程度でほぼ落ち着いた。 残念ながら赤みなどは残っているが、激しかった炎症は落ち着いた。 病院のおかげだ 病院は怖かった#なんか怯えていたので分析してみる。 高額？#病院は高いイメージがあった。初診に数千円取られて、処方箋で2000円とかかかる。割りに合わないと思っていた。 とはいえ実際は、相当安くなっている。 第2医薬品とか薬局で探して塗っていても結局治らない。そういうのを素人判断で購入して使って結果が出ないと嘆いてしまう。トータルで見ると割に合わないよなあと。 診察早すぎない？#医者が診察で5分程度で判断できるわけないだろ！とか馬鹿だから思っていたけど、今思うと何千人も症状を見ており、ほぼ毎日いろいろなケースを知っている医者であれば、そんなん当たり前だよなと思う。 僕にとっては未知の重大なケースでも、医者にとっては日常茶飯事なケースなんだろう。 どこいけばいい？#体内部の痛み→内科皮膚の炎症→皮膚科傷など→外科 あと耳鼻科とかは耳だし、目は眼科だよな。そのままやね。いろんなケースがあるから別れているんだなあ。 余談：お薬手帳はお得なのでおすすめ#薬局務めの人に教えてもらったのだけど、お薬手帳を持っていくと、薬が少し安くなるらしい。そりゃ作って持っていくほうがいいよね。そこまで手間でないんだから。 あと、過去の処方箋の履歴を確認したり、トリプルチェックとかを挟んでいるから、少し時間がかかるのは仕方ないらしい。まあ安心だよね。それが。 あと薬局が多いのは、薬をすべて置ききれないから。病院で処方されるのは処方内容によって違う。となると小さな薬局におけるケースは限界ある。一応どこの処方箋でも受けられるけど、近くの病院から出がちな処方箋のほうが他のものより多く在庫を抱えるよねという話、なので病院前の薬局が多い。","link":"/2022/09/27/lifestyle/"},{"title":"エンコード処理と認証によるセキュアプログラミング","text":"セキュアなプログラミング(表示に関して) ブラウザにデータを渡す際もセキュアな設定が必要 ブラウザに渡すとき DBに渡すとき フレームワークを使うか、使用するメソッドなどを定義しておく データを渡すあらゆる箇所にエンコード処理は必要 アクセス制御について 認証と認可を組み合わせてアクセス制御を行う アクセス制御の不備の事例 アクセス制御はあらゆるアプリ（サービス単位で）見るべき 認証と認可の指標 他の人に情報を与えない 1つの方法が突破されても複数の突破が必要になる 認証認可周りはログを残す セキュアなプログラミング(表示に関して)#入力値検証→処理→DBやブラウザへの受け渡しというフローでは下記のようなケースでは、入力値検証としては正しいが、DBにわたすときにすると全件を取得しうる'aiueo'or'1'!='@examle.com 処理が誤解・誤動作しないようにエスケープとエンコードを行う ブラウザにデータを渡す際もセキュアな設定が必要#例えば、タグの説明をする場合は、タグと文字列を区別する必要がある。エンコードによってエスケープする必要がある。 ブラウザに渡すとき#HTMLエンティティエンコーディング→PHPであれば、htmlspecialcharsによってエンコーディング DBに渡すとき#プリペアステートメント フレームワークを使うか、使用するメソッドなどを定義しておく#フレームワークとかは自動で設定してくれることが多いので、特徴を確認して、FWを使おうね（忘れてしまうので） 約束事は決めておいて共有しておくことが大事 DBの取得はFWのfindメソッドを使う・・・など。 データを渡すあらゆる箇所にエンコード処理は必要#渡す処理だけエンコードが必要-&gt; エンコードされていないように見える場合は理由をコメントアウト等に記載（コードレビュー） アクセス制御について#WOASPのTOP10として脅威になっている 認証を突破されると下記のような事例がある。 ユニクロのパスワードリスト攻撃 他人の注文履歴が見える アクセス制御によって、与えられた権限のみ利用できるようにする（IAMなど） 認証と認可を組み合わせてアクセス制御を行う#認証（本人確認）と認可（権限の許可）を組み合わせて利用する アクセス制御の不備の事例#直接リクエストするとだめなケース（curlなど）注文取る奥画面にはアクセスできないがAPIはアクセスできてしまう・・・ アクセス制御はあらゆるアプリ（サービス単位で）見るべき#WebアプリだけでなくAzureやCMysqlなどLIなどでもいくつも認証される 認証と認可の指標#Authentication Cheat SheetAuthorization Cheat Sheet 他の人に情報を与えない#攻撃者のヒントに鳴るエラーメッセージは避けるIDとパスワードを入力して失敗したときに、「パスワードが間違っています」（暗にIDとはあっていると説明している） 1つの方法が突破されても複数の突破が必要になる#再認証は、session IDなどをなりすましたときに使える全権限を持つユーザーは作らない 認証認可周りはログを残す#認可で拒否されたリクエストはロギングする。バグか悪意にあるアタックなのかを判断できる","link":"/2022/09/26/security/"},{"title":"ビジネス面でのリスクを考える","text":"ビジネス的リスクについて 例 リスクプロファイリングを行いリスクを洗い出す PMBOKでマネジメント手法を知る キックオフミーティングが大事 ビジネス的リスクについて#顧客や自分自身が想定した期待値から異なっていること 顧客との想定運用とズレが発生したため手戻り改修が発生した アクセス総数が想定の数倍多く、サーバーがダウンした ビジネス的観点から重要なウェイトをおいている箇所を把握できておらず、必要な仕組みを構築できていなかった（顧客情報の変更攻撃に対する攻撃ロギングシステムなど） 技術的観点でいうと、、、 作成したロジックの戻り値が配列を想定していたが、特定のケースではnullが返却される ユーザーがログインしているときに表示するCMSを未ログインユーザーに対しても表示していた とかかな。 こういったケースは「知識」による「識別」によって把握できる。何が起こると困るのか、誰がどの程度困るのかのケースを認識していれば、想定外の事態を引き起こすことがなくなる（つまりリスクが減らせる） 例#メールアドレスaiueo=1'or'@example.com &quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt; メールの要件は満たしているが、DBの対象とならない。SQLインジェクションによるアタック対象となったり、XSS攻撃の対象となる 業務要件にあった入力値検証(ホワイトリストorブラックリスト)が必要 リスクプロファイリングを行いリスクを洗い出す#想定外の事態を防ぐために行う行為がリスクプロファイリング。 なぜこの機能が必要か、どういう役割で機能しているか なぜ特定のレベルの稼働が求められるのか、SLAや性能は？同時アクセスの程度は？ インシデントの対応は？異常検知や障害対応などの許容範囲は？アラートレベルは？ 顧客のコアバリューは？ PMBOKでマネジメント手法を知る#PMBOKは、プロジェクトマネジメントに関するノウハウ集。1987年に原案が発表されてから広く知られている。リスクを軽減するプロジェクトマネジメント手法 キックオフミーティングが大事# 受注経緯や背景の共有 顧客の機体事項の説明 開発方針 リスクの共有など →メンバーがタスク単位でしか関われないため指示作業通りの設計しかできない→顧客の要望を理解していないため、言われたことしかできない状態に陥る。→貴重なリスクを見逃してしまう","link":"/2022/09/26/risk/"}],"tags":[{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"phpunit","slug":"phpunit","link":"/tags/phpunit/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"expansion","slug":"expansion","link":"/tags/expansion/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"},{"name":"shortcut","slug":"shortcut","link":"/tags/shortcut/"},{"name":"SVNTortoise","slug":"SVNTortoise","link":"/tags/SVNTortoise/"},{"name":"diet","slug":"diet","link":"/tags/diet/"},{"name":"ちょっとした疑問","slug":"ちょっとした疑問","link":"/tags/%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%97%E3%81%9F%E7%96%91%E5%95%8F/"},{"name":"お酒","slug":"お酒","link":"/tags/%E3%81%8A%E9%85%92/"},{"name":"100list","slug":"100list","link":"/tags/100list/"},{"name":"環境構築","slug":"環境構築","link":"/tags/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/"},{"name":"本","slug":"本","link":"/tags/%E6%9C%AC/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"非同期処理","slug":"非同期処理","link":"/tags/%E9%9D%9E%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86/"},{"name":"sed","slug":"sed","link":"/tags/sed/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"HowTo","slug":"HowTo","link":"/tags/HowTo/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"lifestyle","slug":"lifestyle","link":"/tags/lifestyle/"},{"name":"risk","slug":"risk","link":"/tags/risk/"}],"categories":[{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"Excel","slug":"Excel","link":"/categories/Excel/"},{"name":"SVN","slug":"SVN","link":"/categories/SVN/"},{"name":"lifestyle","slug":"lifestyle","link":"/categories/lifestyle/"},{"name":"おすすめ","slug":"おすすめ","link":"/categories/%E3%81%8A%E3%81%99%E3%81%99%E3%82%81/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"プログラミング","slug":"プログラミング","link":"/categories/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/"},{"name":"趣味","slug":"趣味","link":"/categories/%E8%B6%A3%E5%91%B3/"}],"pages":[]}